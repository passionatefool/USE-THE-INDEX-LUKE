# 慢索引，第一部分

尽管树遍历的效率很高，但是仍然存在索引的查找没有预期中的那么快的情况。长期以来，这种索引退化的矛盾推动了一种玄学，
该玄学认为索引重建是神奇的解决方案。但是现在，你可以理所当然地认为从长远来看，重建索引并不能提高性能。在这几节的基础上，
我们知道在一些简单语句中即使使用索引也会变得很慢的真正原因。

慢索引的第一个原因是叶子节点链。我们再回到 [图 1.3](./img/figure1.3.png) 中对 "57" 的搜索。显然，我们知道索引中有两个匹配项。
至少有两个条目是相同的，更准确地说：下一个叶子节点也可能有 57 的条目。数据库必须读取下一个叶子节点，以查看是否还有其他匹配项。
这意味着索引查找不仅需要执行树的遍历，还需要通过叶子节点链查找。

慢索引的第二个原因是访问表。即使是一个叶子节点也可能包含许多次访问（通常是数百次）。对应的表数据通常分散在许多表块中
（参见 [图 1.1，索引叶子节点和对应的表数据](./img/figure1.1.png)）。这意味着每次命中都会额外地访问表一次。

索引的查找需要三个步骤：1.遍历树；2.通过叶子节点链查找；3.回表取数据。遍历树是唯一一个对访问块的次数有上限的步骤。
其他两个步骤可能需要访问许多块，这是导致索引查找变慢的原因。

慢索引玄学的起源是一种误解，即索引查找只是遍历树，因此认为慢索引一定是由被破坏或者不平衡的树引起的。事实上，
您可以查一下大多数数据库是如何使用索引的。Oracle 数据库在这方面的描述非常详尽，有三种不同的操作来描述基本的索引查找。

## 唯一索引扫描（INDEX UNIQUE SCAN）
唯一索引扫描仅执行树遍历。如果唯一性约束能确保搜索条件匹配的条目不超过一个，那么 Oracle 数据库就会使用此操作。

## 索引的范围扫描（INDEX RANGE SCAN）
索引的范围扫描会执行树的遍历，并跟踪叶子节点链找到所有匹配项。如果有多个条目可以匹配到搜索条件，那这种就是回退操作。

## 通过索引 rowID 访问表（TABLE ACCESS BY INDEX ROWID）
通过索引 rowID 访问表的操作可以从表中取出我们需要的行。这个操作（通常）会对前一个操作（即索引的范围扫描）得到的每一个数据
都回表查找到对应的数据。

最重要的一点是，索引的范围扫描会潜在地读取索引的大部分内容。如果读取到的每一行都去访问表， 那么即使使用索引，查询也会变慢。
