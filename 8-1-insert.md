## INSERT

表索引数量是影响`insert`性能的最主要的因素。一个表的索引数量越多，其执行速度就越慢。`insert`语句是唯一不能直接从索引获益的操作，因为它没有`where`子句。

向表中添加新行包含几个步骤。首先，数据库必须找一个位置来存放它。对于没有特定行顺序的常规堆表，数据库可以使用任何具有足够空间的表块。这是一个非常简单和快速的过程，主要在内存中执行。之后数据库要做的就是将新条目添加到相应的数据块中。

如果表里有索引，数据库必须确保这些新条目也能通过索引被找到。出于这个原因，数据库必须将新条目添加到该表的每个索引中去。因此，索引的数量是插入语句成本的乘数。

此外，向索引中添加一个条目比向堆结构中插入一个条目的代价要高得多，因为数据库必须保持索引顺序和树的平衡。这意味着新条目不能任意写入到一个块——它属于特定的叶子节点。尽管数据库使用索引树本身来寻找正确的叶子节点，但它仍然需要为了遍历树而读取一些索引块。

一旦确定了正确的叶节点，数据库就会确认该节点中是否有足够的可用空间。如果没有，数据库将拆分叶节点，并在旧节点和新节点之间分配条目。这个过程还会影响相应分支节点中的引用，因为这些引用也必须被复制。不用说，分支节点也可能会耗尽空间，因此可能也必须对其进行拆分。在最坏的情况下，数据库必须将所有节点拆分，直到根节点。这是树获得额外的层和增加深度的唯一情况。

毕竟，索引维护是插入操作中开销最大的部分。这在[图8.1 “Insert 性能和索引数量关系”](#图 8.1 Insert 性能和索引数量关系)中也可见：如果表没有任何索引，那么执行时间几乎不可见。然而，添加一个索引就足以将执行时间增加100倍。每增加一个索引，执行速度就会进一步减慢。

#### 图 8.1 Insert 性能和索引数量关系

<img src="./img/fig08_01_insert.en.DLWZBgPu.png" alt="Figure 8.1 " style="zoom:150%;" />



> 💡NOTE
>
> 第一个索引的差异最大。

为了优化插入性能，保持较少的索引数量是非常重要的。



> 💡TIP
>
> 谨慎使用索引，尽可能避免冗余索引。这也有利于删除和更新语句。

只考虑插入语句，最好完全避免索引，这将产生最好的插入性能。然而，没有索引的表在实际应用程序中是非常不现实的。您通常希望再次检索存储的数据，以便需要索引来提高查询速度。即使是只写日志表通常也有一个主键和一个相应的索引。

然而，没有索引的性能是如此之好，以至于在加载大量数据时临时删除所有索引是有意义的，前提是其他SQL语句同时不需要这些索引。这可以释放一个戏剧性的加速，这在图表中是可见的，事实上，这是数据仓库的一种常见做法。



> 💡THINK
>
> 当使用索引组织表或聚集索引时，[图8.1](#图 8.1 Insert 性能和索引数量关系)会如何变化?
>
> 插入语句是否有任何可以从索引中收益的间接方式？也就是说，是否有额外的索引可以使插入语句更快？



