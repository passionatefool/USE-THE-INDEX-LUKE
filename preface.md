# 开发者需要使用索引

SQL 的性能问题与 SQL 本身一样古老 -- 有些人会说 SQL 天生就很慢。
虽然在 SQL 的早期这种说法可能是对的，但是现在肯定不正确。然而 SQL 的性能问题依旧普遍存在，这是怎么发生的？

SQL 语言大概是最成功的第四代编程语言（Fourth-generation programming language - 4GL）。
它最大的优点是区分 "是什么" 和 "如何实现" 的能力。一条 SQL 语句可以直接描述它需要什么，而不需要说明如何实现它。
来看看下面的例子：

```
SELECT date_of_birth
FROM employees
WHERE last_name = 'WINAND'
```

这条 SQL 查询读起来就像英语句子一样去解释要请求的数据。编写 SQL 语句基本不需要知道数据库内部是如何实现的
或者存储系统是如何工作的（如磁盘，文件等）。 我们不需要告诉数据库要打开哪一个文件或者找到我们请求的那行数据。
许多开发者有多年的 SQL 经验，但是他们对数据库里面所发生的过程了解得非常少。

在 SQL 中，关注点的分离（需要什么 vs 如何得到它）取得显著的成功，但是它仍然是不完美的。
这种抽象会在性能方面遇到瓶颈：SQL 语句的作者并不关心数据库是如何执行该语句的。因此，写 SQL 语句的人并不用对慢查询负责。
然而，经验证明恰恰相反，也就是说为了防止遇到性能问题，写 SQL 的人必须要了解一些关于数据库的知识。

事实证明，开发人员需要学习的唯一一件事就是如何建立索引。数据库索引实际上是一项开发任务。这是因为创建适当的索引的重要的依据
并不是存储系统或者硬件的配置，最重要的是应用程序是如何查询数据的。数据库管理员（DBA）或者外部顾问并不是很容易去获取到
这些信息（通过程序逆向工程收集这些信息需要很长时间）。但是，开发者是有这些信息的。

这本书涵盖了开发人员需要了解的所以关于索引的知识，仅此而已。更准确地说，这本书只涵盖了最重要的索引类型：B-tree 索引。

B-tree 索引在许多数据库中几乎完全相同。这本书主要使用 Oracle 数据库的术语，但会在适当的地方引用其他数据库相应的术语。
本书的结构是对开发人员量身定制的。大部分章节对应于 SQL 语句的特定部分。

## [第一章](./anatomy.md) - 解剖索引

第一章是唯一没有专门介绍 SQL 的章节，而是介绍索引的基本结构。理解索引的结构对后面的章节非常重要，所以不要跳过这一章！
虽然这一章很短，大概只有八页，但在看完这章后，你将会理解慢索引这一现象。

## [第二章](./where-clause.md) - Where 字句

这是我们将付诸全力之处。本章介绍了 where 字句的所有方面，从非常简单的单列查询到用于范围以及 LIKE 等特殊情况的复杂字句。
这一章是这本书的主要内容。一旦你学会了使用这些技术，你将会编写出更快的 SQL。

## [第三章](./testing-scalability.md) - 性能与可扩展性

本章是关于性能的度量和数据库的可扩展性，可能有点离题。我们将了解为什么添加硬件并不是解决慢查询的最佳解决方案。

## [第四章](./join.md) - JOIN 操作

重回 SQL：这里将解释如何使用索引使 JOIN 操作更加快。

## [第五章](./clustering.md) - 聚合数据（Clustering Data）

你是否有想过选择一列和所有列之间是否有任何区别？下面是答案和获得更好性能的技巧。

## [第六章](./sorting-grouping.md) - 排序和分组（Sorting and Grouping）

甚至连 ORDER BY 与 GROUP BY 都可以使用索引。

## [第七章](./partial-results.md) - 部分结果（Partial Results）

本章将解释如果你不需要完整的结果集合，如何从 pipelined 中获益。


## [第八章 - INSERT，DELETE 与 UPDATE](./8-dml.md)

索引如何影响写入性能？索引不是无代价的 -- 明智地使用它们！
